import React, { useState, useEffect, useCallback } from 'react';
// We use direct imports for standard NPM packages in a deployable environment
import { initializeApp } from 'firebase/app';
import { getAuth, signInAnonymously } from 'firebase/auth'; 
import { getFirestore } from 'firebase/firestore'; 
import { Loader2, Zap, Shirt, Image, Edit, PlusCircle, CheckCircle, Diamond, KeyRound } from 'lucide-react';

// --- Configuration for Deployment ---
// IMPORTANT: Replace the placeholder values below with your actual Firebase project configuration 
// when you prepare for deployment (e.g., using environment variables or a configuration file).
const MOCK_FIREBASE_CONFIG = {
    apiKey: "YOUR_API_KEY_HERE", 
    authDomain: "your-project-id.firebaseapp.com",
    projectId: "your-project-id",
    storageBucket: "your-project-id.appspot.com",
    messagingSenderId: "1234567890",
    appId: "1:1234567890:web:abcdefg"
};

const firebaseConfig = MOCK_FIREBASE_CONFIG; 
const appId = 'legods-nft-editor-v1'; // Static ID for deployment purposes
const isMocked = firebaseConfig.projectId === "your-project-id";

// Placeholder for initial display 
const DEFAULT_IMAGE_URL = 'https://placehold.co/400x500/1e293b/94a3b8?text=Enter+NFT+Token+ID';

// --- NFT Configuration ---
const LEGODS_CONTRACT_ADDRESS = "0xad9951b55C675664D9619b46483E9F65a57aB5E6"; 
// This simulates fetching a unique base image based on the token ID in a sandbox environment.
const PLACEHOLDER_NFT_IMAGE_URL = 'https://placehold.co/400x500/1e293b/94a3b8?text=NFT+ID+';

// Define the available clothing and accessory options, highly stylized for the NFT aesthetic
const CLOTHING_OPTIONS = [
    {
        category: 'Hats & Crowns',
        key: 'headwear',
        items: [
            { id: 'h0', name: 'Keep Original', prompt: '' }, 
            { id: 'h0-remove', name: 'Remove/Clear', prompt: 'remove any headwear or accessory from the head' },
            { id: 'h1', name: 'Gold Crown (Logo)', prompt: 'a massive, heavy gold crown with blue gems and the **LeGods logo** prominently featured on the crown, maintaining the current style' },
            { id: 'h2', name: 'Futuristic Helmet (Logo)', prompt: 'a sleek, dark red and black futuristic motorcycle helmet with a visor and the **LeGods logo** prominently featured on the helmet' },
            { id: 'h3', name: 'Black Beanie (Logo)', prompt: 'a simple, high-contrast, black knit beanie hat with the **LeGods logo** prominently featured on the hat' },
            { id: 'h4', name: 'Spiked Mohawk', prompt: 'a vibrant red spiked mohawk hairstyle, matching the illustration style' }, 
            { id: 'h5', name: 'Chrome Samurai (Logo)', prompt: 'a detailed chrome and black cyberpunk samurai helmet with the **LeGods logo** prominently featured on the helmet' },
            { id: 'h6', name: 'Neon Halo', prompt: 'a glowing cyan circular halo above the head' }, 
            { id: 'h7', name: 'Visor Cap (Logo)', prompt: 'a black baseball cap with an integrated green LED strip visor and the **LeGods logo** prominently featured on the cap' },
            { id: 'h8', name: 'Dark Jester Hat (Logo)', prompt: 'a stylized, high-contrast black and purple jester hat with the **LeGods logo** prominently featured on the hat' },
            { id: 'h9', name: 'Neon Santa Hat (Logo)', prompt: 'a high-contrast, black and neon green Santa hat with the **LeGods logo** prominently featured on the hat, maintaining the cyberpunk style' },
            { id: 'h10', name: 'Jingling Antlers', prompt: 'chrome reindeer antlers with glowing red bells attached' }, 
            { id: 'h11', name: 'Party Popper Headband', prompt: 'a large, tacky headband with miniature party poppers exploding above the head' }, 
            { id: 'h12', name: 'Festive Gold Wreath (Logo)', prompt: 'a massive, heavy gold wreath crown with bright red and green neon berries and lights and the **LeGods logo** prominently featured on the crown' },
        ],
    },
    {
        category: 'Glasses',
        key: 'glasses',
        items: [
            { id: 'g4', name: 'Keep Original', prompt: '' }, 
            { id: 'g4-remove', name: 'Remove/Clear', prompt: 'remove any glasses, shades, or visor from the face' },
            { id: 'g1', name: 'Laser Visor', prompt: 'a glowing cyan single-strip laser visor covering the eyes' }, 
            { id: 'g2', name: 'Gold-Rim Shades', prompt: 'dark, gold-rimmed round sunglasses in the cartoon style' }, 
            { id: 'g3', name: 'Holographic Goggles (Logo)', prompt: 'a set of large, reflective, orange holographic goggles resting on the forehead with the **LeGods logo** prominently featured on the goggles frame' },
            { id: 'g5', name: 'X-Ray Goggles (Logo)', prompt: 'large, blocky goggles with a glowing green lens effect and the **LeGods logo** prominently featured on the goggles frame' },
            { id: 'g6', name: 'Gold Monocle', prompt: 'a stylized gold monocle integrated with a facial tech piece' }, 
            { id: 'g7', name: 'Half-Frame Shades', prompt: 'angular, reflective red half-frame sunglasses' }, 
            { id: 'g8', name: 'Giant Googly Eyes', prompt: 'oversized, cartoonishly large googly eye glasses' }, 
            { id: 'g9', name: 'Flashing LED Shades', prompt: 'large, novelty star-shaped shades with flashing red and green LED lights' }, 
            { id: 'g10', name: 'Snowflake Goggles (Logo)', prompt: 'sleek, chrome cyberpunk goggles with large, sharp, glowing blue snowflake lenses and the **LeGods logo** prominently featured on the goggles frame' },
        ],
    },
    {
        category: 'Jackets & Jumpers',
        key: 'jacket',
        items: [
            { id: 'j0', name: 'Keep Original', prompt: '' },
            { id: 'j0-remove', name: 'Remove/Clear', prompt: 'remove any jacket, armor, or outer garment' },
            { id: 'j1', name: 'Spiked Leather (Logo)', prompt: 'a black leather motorcycle jacket covered in chrome spikes and the **LeGods logo** prominently featured on the back or chest' },
            { id: 'j2', name: 'Neon Bomber (Logo)', prompt: 'a vivid pink and cyan striped futuristic bomber jacket with the **LeGods logo** prominently featured on the back or chest' },
            { id: 'j3', name: 'Heavy Gold Armor (Logo)', prompt: 'a solid, heavy, gold-plated, futuristic shoulder armor piece with the **LeGods logo** prominently featured on the shoulder plate' },
            { id: 'j4', name: 'Black Roll-Neck (Logo)', prompt: 'a heavy black roll-neck or turtleneck sweater with the **LeGods logo** prominently featured on the neck or chest' },
            { id: 'j5', name: 'Luxury Fur Coat', prompt: 'a massive, expensive white fur coat draped over the shoulders' }, 
            { id: 'j6', name: 'Camo Parka (Logo)', prompt: 'a bulky, stylized digital camouflage parka with large pockets and the **LeGods logo** prominently featured on the chest' },
            { id: 'j7', name: 'Sleek Trench (Logo)', prompt: 'a long, flowing, high-contrast black leather trench coat with the **LeGods logo** prominently featured on the back' },
            { id: 'j8', name: 'Metallic Track Suit (Logo)', prompt: 'a metallic silver futuristic track suit jacket with the **LeGods logo** prominently featured on the chest' },
            { id: 'j9', name: 'Basketball Jersey (Logo)', prompt: 'an oversized, vivid yellow and black basketball jersey with the **LeGods logo** prominently featured on the front' },
            { id: 'j10', name: 'Ugly Xmas Cyber-Sweater (Logo)', prompt: 'a high-contrast, black and bright green Ugly Christmas Sweater featuring a pixelated skull pattern with the **LeGods logo** replacing or adjacent to the skull pattern' },
            { id: 'j11', name: 'Giant Elf Costume (Logo)', prompt: 'an cartoonishly oversized green and red elf costume jacket with exaggerated collar and the **LeGods logo** prominently featured on the chest' },
            { id: 'j12', name: 'Reflective Tinsel Cape', prompt: 'a flowing cape made entirely of sharp, highly reflective silver and red tinsel material' }, 
        ],
    },
    {
        category: 'T-Shirts & LeGods',
        key: 'top',
        items: [
            { id: 't0', name: 'Keep Original', prompt: '' },
            { id: 't0-remove', name: 'Remove/Clear', prompt: 'remove any t-shirt, top, or inner garment' },
            { id: 't1', name: 'Cyber Vest (Logo)', prompt: 'a tight, shiny, black futuristic tank top or vest with the **LeGods logo** prominently featured on the chest' },
            { id: 't2', name: 'Vintage Band Tee (Logo)', prompt: 'a ripped vintage band t-shirt with a faded logo. Replace the faded logo with the **LeGods logo**' },
            { id: 't3', name: 'Clean White T-Shirt (Logo)', prompt: 'a clean, high-contrast white t-shirt with the **LeGods logo** prominently featured on the chest' },
            { id: 't4', name: 'Black Sleeveless Hoodie (Logo)', prompt: 'a simple, dark, sleeveless athletic hoodie with the **LeGods logo** prominently featured on the chest' },
            { id: 't5', name: 'Net Tank Top (Logo)', prompt: 'a provocative black mesh/net tank top with the **LeGods logo** rendered in metallic silver on the chest' },
            { id: 't6', name: 'Tattooed Chest (Logo)', prompt: 'the chest and arms are covered in intricate, stylized graphic tattoos, including a prominent **LeGods logo tattoo** on the chest' },
            { id: 't7', name: 'Logo Hoodie (LeGods)', prompt: 'a simple, dark hoodie with a large, minimalist white **LeGods logo** on the chest' },
            { id: 't8', name: 'Shoulder Armor Plate (Logo)', prompt: 'a high-tech, black and red chest armor plating piece with the **LeGods logo** etched into the armor' },
            { id: 't9', name: 'Santa Vest & Abs (Logo)', prompt: 'a graphic, cartoonishly muscular chest wearing a ripped red Santa Claus vest with the **LeGods logo** on the vest' },
            { id: 't10', name: 'Festive Turtleneck (Logo Pattern)', prompt: 'a tightly fitted, high-contrast, black turtleneck featuring a repeating white **LeGods logo pattern**' },
            { id: 't11', name: 'Black Ice T-Shirt (Logo)', prompt: 'a tight black shirt with a massive, stylized white skull made of cracked ice on the chest. Replace the skull with the **LeGods logo** made of cracked ice' },
        ],
    },
    {
        category: 'Chains & Neckwear',
        key: 'chain',
        items: [
            { id: 'c4', name: 'Keep Original', prompt: '' },
            { id: 'c4-remove', name: 'Remove/Clear', prompt: 'remove any chain or neckwear' },
            { id: 'c1', name: 'Thick Silver (Logo)', prompt: 'a very thick, heavy chrome silver chain necklace with a small **LeGods logo pendant**' },
            { id: 'c2', name: 'Diamond Pendant (Logo Shape)', prompt: 'a large, glowing diamond pendant on a thin silver chain. The pendant is shaped like the **LeGods logo**' },
            { id: 'c3', name: 'Heavy Gold Chain (Logo)', prompt: 'an extremely thick, cuban link gold chain necklace with a small **LeGods logo pendant**' },
            { id: 'c5', name: 'Padlock Chain (Logo)', prompt: 'a chunky silver chain with a prominent industrial padlock hanging from it. The padlock features the **LeGods logo**' },
            { id: 'c6', 'name': 'Chrome Dog Tag (Logo)', prompt: 'a polished chrome military-style dog tag necklace. The dog tag displays the **LeGods logo**' },
            { id: 'c7', name: 'Silk Scarf (Logo Pattern)', prompt: 'a luxurious, patterned silk scarf draped loosely around the neck. The pattern includes the **LeGods logo**' },
            { id: 'c8', name: 'Tacky LED Lights (Logo)', prompt: 'a necklace made of a string of cheap, glowing, multicolored Christmas LED lights, which form the shape of the **LeGods logo**' },
            { id: 'c9', name: 'Oversized Candy Cane (Logo)', prompt: 'an absurdly large chain made of reflective, twisting red and white candy canes, featuring a **LeGods logo pendant** made of candy cane material' },
            { id: 'c10', name: 'Bell Choker (Logo)', prompt: 'a tight, black leather choker with small, heavy chrome jingle bells attached and a **LeGods logo charm**' },
        ],
    },
    {
        category: 'Facial Traits',
        key: 'face_trait',
        items: [
            { id: 'f3', name: 'Keep Original', prompt: '' },
            { id: 'f3-remove', name: 'Remove/Clear', prompt: 'remove any facial trait, mask, or marking' },
            { id: 'f1', name: 'Cybernetic Scars (Logo)', prompt: 'vivid blue glowing lines resembling scars on the cheek/forehead that form the shape of the **LeGods logo**' },
            { id: 'f2', name: 'Pixelated Balaclava (Logo)', prompt: 'a high-contrast black and white pixelated balaclava covering the lower face with the **LeGods logo** printed on it\'s surface' },
            { id: 'f4', name: 'Bionic Jaw (Logo)', prompt: 'a partial chrome jaw and lower face replacement with the **LeGods logo** etched into the metal' },
            { id: 'f5', name: 'Glowing Red Eyes', prompt: 'the eyes are solid, glowing red color' }, 
            { id: 'f6', name: 'Gas Mask (Logo)', prompt: 'a futuristic black gas mask covering the lower half of the face with the **LeGods logo** printed on the filter' },
            { id: 'f7', name: 'Rudolph Red Nose', prompt: 'a small, glowing red, cartoon-style Rudolph nose' }, 
            { id: 'f8', name: 'Oversized Smile', prompt: 'an extremely large, white-toothed cartoon smile drawn across the face' }, 
            { id: 'f9', name: 'Icy Beard', prompt: 'a highly stylized, frosted white beard made of sharp, crystalline ice' }, 
            { id: 'f10', name: 'Cracked Gingerbread Mask (Logo)', prompt: 'a broken, cracked gingerbread cookie mask covering the mouth and nose with the **LeGods logo** etched into the cookie' },
        ],
    },
    {
        category: 'Background',
        key: 'background',
        items: [
            { id: 'bb1', name: 'Solid Black (Base)', prompt: 'a simple solid black background' },
            { id: 'bb2', name: 'Solid Red', prompt: 'a simple solid vibrant red background' },
            { id: 'bb3', name: 'Solid Blue', prompt: 'a simple solid neon blue background' },
            { id: 'bb4', name: 'Solid Green', prompt: 'a simple solid high-contrast lime green background' },
            { id: 'bb5', name: 'Solid Yellow', prompt: 'a simple solid bright yellow background' },
            { id: 'bb6', name: 'Solid White', prompt: 'a simple solid high-contrast white background' },
            { id: 'b2', name: 'Neon City Street', prompt: 'a vivid neon cyberpunk city street background with rain effects' },
            { id: 'b3', name: 'Geometric Abstract', prompt: 'a high-contrast, pink and blue geometric abstract pattern background' },
            { id: 'b4', name: 'Volcanic Wasteland', prompt: 'a dark, smoky volcanic wasteland with red lightning in the sky' },
            { id: 'b5', name: 'Data Stream Matrix', prompt: 'a background filled with green glowing data streams, like the matrix' },
            { id: 'b6', name: 'Rainy Temple Ruins', prompt: 'ancient, dark temple ruins in a torrential downpour' },
            { id: 'b7', name: 'Cosmic Nebula', prompt: 'a swirling, vibrant purple and blue cosmic nebula background' },
            { id: 'b8', name: 'Cyberpunk Snowscape', prompt: 'a hyper-stylized, high-contrast snowy cyberpunk street at night, with dark, wet pavement and neon signs' },
            { id: 'b9', name: 'Candy Cane Matrix', prompt: 'an abstract, swirling background of high-contrast red and white candy cane stripes' },
            { id: 'b10', name: 'Melted Gingerbread House', prompt: 'a surreal, high-contrast background depicting a melted gingerbread house in a dark, neon alley' },
            { id: 'b11', name: 'Frozen Data Stream', prompt: 'a dark, highly detailed background showing frozen, crystalline data streams and broken servers in a sub-zero environment' },
        ],
    },
];

/**
 * Utility function for exponential backoff retry logic.
 */
const withRetry = async (fn, maxRetries = 3) => {
    for (let i = 0; i < maxRetries; i++) {
        try {
            return await fn();
        } catch (error) {
            if (i === maxRetries - 1) throw error;
            const delay = Math.pow(2, i) * 1000 + Math.random() * 1000;
            await new Promise(resolve => setTimeout(resolve, delay));
            console.warn(`Retry attempt ${i + 1} failed. Retrying in ${delay / 1000}s...`);
        }
    }
    throw new Error("Maximum retries reached."); 
};

/**
 * Utility function to fetch an image URL and convert it to a Base64 Data URL.
 */
const urlToBase64 = async (url) => {
    const response = await fetch(url);
    if (!response.ok) throw new Error("Failed to fetch image from URL.");
    
    const blob = await response.blob();
    
    return new Promise((resolve) => {
        const reader = new FileReader();
        reader.onloadend = () => resolve(reader.result);
        reader.readAsDataURL(blob);
    });
};

const App = () => {
    // System instruction to strictly enforce style and safety constraints
    const SYSTEM_INSTRUCTION = "You are an NFT image editor specialized in the **LeGods Cyborg Illustration Style** (high-contrast, bold, graphic, cyberpunk aesthetic). Your task is to edit the input image based on the user's instructions while strictly maintaining this style. You MUST refuse to process or output any image that depicts **real people**, **realistic photos**, **purely non-human characters** (e.g., animals, monsters, inanimate objects, except for the allowed cyborg figures), or anything outside of this specific style. IMPORTANT SAFETY RULE: You must NEVER generate **explicit, sexual, or nude content**. Ensure all figures are appropriately covered and adhere to strict safety standards, regardless of the user's input prompt. If the input image does not match the LeGods Cyborg Illustration Style, state that you can only edit LeGods NFT characters, and do not generate an image.";

    // --- State Management ---
    const [db, setDb] = useState(null);
    const [auth, setAuth] = useState(null);
    const [userId, setUserId] = useState(null);
    const [isAuthReady, setIsAuthReady] = useState(isMocked); // Ready if mocked, wait if real config is present

    const [nftTokenId, setNftTokenId] = useState(''); 
    const [inputImageBase64, setInputImageBase64] = useState(null);
    const [generatedImageUrl, setGeneratedImageUrl] = useState(null);
    
    const [selectedItems, setSelectedItems] = useState(() => {
        const initialSelections = {};
        CLOTHING_OPTIONS.forEach(category => {
            const defaultItem = category.items.find(i => i.prompt === '') || category.items[0]; 
            initialSelections[category.key] = defaultItem;
        });
        return initialSelections;
    });
    
    const [loading, setLoading] = useState(false);
    const [error, setError] = useState(null);
    const isImageLoaded = !!inputImageBase64;

    // --- Firebase Initialization and Auth for Standard React ---
    useEffect(() => {
        // Only run if a non-mock config is used
        if (isMocked) {
            setUserId('MOCK_USER_ID');
            return;
        }

        let isMounted = true;
        
        const initializeFirebase = async () => {
            try {
                const app = initializeApp(firebaseConfig);
                const firestoreDb = getFirestore(app);
                const firebaseAuth = getAuth(app);

                if(isMounted) {
                    setDb(firestoreDb);
                    setAuth(firebaseAuth);
                }

                // Standard deployment uses Anonymous Sign-In for simple data persistence
                const userCredential = await signInAnonymously(firebaseAuth);
                if (isMounted) {
                    setUserId(userCredential.user.uid);
                    setIsAuthReady(true);
                }
            } catch (e) {
                console.error("Failed to initialize Firebase or sign in:", e);
                if(isMounted) {
                    setError("Failed to initialize the application services. Check Firebase config.");
                    setIsAuthReady(true); 
                }
            }
        };

        initializeFirebase();

        return () => {
            isMounted = false;
        };
    }, []); // Run only once on mount

    // Handler for selecting/deselecting an item
    const handleItemSelection = (categoryKey, item) => {
        setError(null);
        setGeneratedImageUrl(null); 
        setSelectedItems(prev => {
            const categoryItems = CLOTHING_OPTIONS.find(c => c.key === categoryKey).items;
            const keepOriginalItem = categoryItems.find(i => i.prompt === '') || categoryItems[0];
            
            if (prev[categoryKey] && prev[categoryKey].id === item.id) {
                 return {
                    ...prev,
                    [categoryKey]: keepOriginalItem,
                };
            } else {
                return {
                    ...prev,
                    [categoryKey]: item,
                };
            }
        });
    };

    // --- NFT Load Handling (Using Token ID to load base image) ---
    const handleNFTLoad = async () => {
        const idNumber = parseInt(nftTokenId);

        if (!nftTokenId || isNaN(idNumber) || idNumber <= 0) {
            setError("Please enter a valid NFT Token ID (a positive number).");
            return;
        }

        setLoading(true);
        setError(null);
        setInputImageBase64(null); 
        setGeneratedImageUrl(null);
        
        try {
            /*
            // --- REAL WORLD SCENARIO ---
            // 1. Get the Image URL from a Metadata API
            const metadataUrl = `https://api.opensea.io/api/v1/asset/${LEGODS_CONTRACT_ADDRESS}/${idNumber}/`;
            const metadataResponse = await fetch(metadataUrl);
            const metadata = await metadataResponse.json();
            const imageUrl = metadata.image_url;
            */

            // --- DEPLOYABLE SIMULATION ---
            // Using a unique placeholder image based on the Token ID for demonstration:
            const simulatedImageUrl = `${PLACEHOLDER_NFT_IMAGE_URL}${idNumber}`;

            // 2. Fetch the image and convert it to Base64
            const base64 = await urlToBase64(simulatedImageUrl);

            // 3. Store the Base64 data
            setInputImageBase64(base64);
            
        } catch (e) {
            console.error("NFT image loading failed:", e);
            setError(`Failed to load image for Token ID ${nftTokenId}. Check console for details. (Note: This is a simulation.)`);
        } finally {
            setLoading(false);
        }
    };


    // --- AI Generation Logic ---
    const generateNewOutfit = useCallback(async () => {
        
        if (!inputImageBase64) {
            setError("Error: Please load the NFT base image using the Token ID before generating.");
            return;
        }

        const selectedDescriptions = Object.values(selectedItems)
            .map(item => item.prompt)
            .filter(prompt => prompt && prompt.length > 0);

        if (selectedDescriptions.length === 0) {
            setError("Please select at least one item of clothing/accessory or a background change.");
            return;
        }

        const descriptionList = selectedDescriptions.join(' and ');
        const finalPrompt = `Change the person in the image to have the following characteristics: ${descriptionList}. Maintain the pose, facial expression, and general lighting.`;

        setLoading(true);
        setError(null);
        
        const parts = inputImageBase64.match(/^data:(.+?);base64,(.+)$/);
        if (!parts || parts.length < 3) {
            setError("Invalid image file format during processing.");
            setLoading(false);
            return;
        }

        const mimeType = parts[1];
        const base64Data = parts[2];
        
        // In a deployed environment, you must securely manage your Gemini API key 
        // (e.g., through a serverless function or environment variables passed to the frontend).
        // For this frontend-only example, we assume the environment handles the key:
        const apiKey = ""; 
        const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-image-preview:generateContent?key=${apiKey}`;

        const payload = {
            contents: [
                {
                    role: "user",
                    parts: [
                        { text: finalPrompt },
                        {
                            inlineData: {
                                mimeType: mimeType,
                                data: base64Data
                            }
                        }
                    ]
                }
            ],
            systemInstruction: {
                parts: [{ text: SYSTEM_INSTRUCTION }]
            },
        };
        
        try {
            const fetchFn = async () => {
                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });

                if (!response.ok) {
                    throw new Error(`API call failed with status: ${response.status}`);
                }

                return await response.json();
            };

            const result = await withRetry(fetchFn);
            
            const candidate = result.candidates?.[0];
            const base64Image = candidate?.content?.parts?.find(p => p.inlineData)?.inlineData?.data;
            const refusalText = candidate?.content?.parts?.[0]?.text;

            if (base64Image) {
                setGeneratedImageUrl(`data:image/png;base64,${base64Image}`);
            } else if (refusalText) {
                setError(`Style Enforcement: ${refusalText}`);
            } else {
                setError("AI did not return an image. This usually happens if the input image is not a stylized character (e.g., a photo).");
            }
        } catch (e) {
            console.error("Image generation error:", e);
            setError(`Failed to generate image: ${e.message || 'Check console for details.'}`);
        } finally {
            setLoading(false);
        }
    }, [inputImageBase64, selectedItems, SYSTEM_INSTRUCTION]);

    // --- Component UI ---

    const displayImage = generatedImageUrl || (isImageLoaded ? inputImageBase64 : DEFAULT_IMAGE_URL);
    const isEditing = generatedImageUrl && !loading;
    const generateButtonEnabled = isImageLoaded && !loading;

    return (
        <React.Fragment>
        <div className="min-h-screen bg-gray-900 p-4 sm:p-6 font-inter antialiased text-white">
            {/* Header */}
            <header className="mb-8 text-center">
                <h1 className="text-3xl font-extrabold text-yellow-400 flex items-center justify-center space-x-3">
                    <Diamond className="h-8 w-8 text-yellow-500" />
                    <span>LeGods Style Generator</span>
                </h1>
                <p className="text-gray-400 mt-1 text-sm sm:text-base">
                    Enter your NFT **Token ID** to fetch the base image and customize it with new traits.
                </p>
                {isMocked && (
                    <p className="text-xs text-red-400 mt-2 p-1 bg-red-900/30 rounded">
                        Mocked Firebase Config in use. Data persistence is disabled.
                    </p>
                )}
                <p className="text-xs text-gray-600 mt-2">
                    Project ID: **{appId}** | User ID: **{userId || 'Anonymous'}**
                </p>
            </header>

            <div className="max-w-6xl mx-auto bg-gray-800 p-6 rounded-2xl shadow-2xl">
                <div className="grid grid-cols-1 lg:grid-cols-2 gap-8">
                    
                    {/* Controls Area (Categories) */}
                    <div className="flex flex-col space-y-6 lg:order-1">
                        <h2 className="text-xl font-semibold text-yellow-400 flex items-center">
                            <Edit className="h-5 w-5 mr-2" />
                            1. Select Your Traits (All include **LeGods** logo)
                        </h2>

                        {CLOTHING_OPTIONS.map((category) => (
                            <div key={category.key} className="p-4 bg-gray-700 rounded-xl shadow-inner border border-gray-600">
                                <h3 className="text-lg font-bold text-gray-200 mb-3">{category.category}</h3>
                                <div className="grid grid-cols-2 sm:grid-cols-3 gap-3">
                                    {category.items.map((item) => {
                                        const isSelected = selectedItems[category.key]?.id === item.id;
                                        return (
                                            <button
                                                key={item.id}
                                                onClick={() => handleItemSelection(category.key, item)}
                                                disabled={loading}
                                                className={`flex items-center justify-center p-3 text-sm rounded-lg border-2 transition duration-150 transform active:scale-95 text-left font-medium 
                                                    ${isSelected 
                                                        ? 'bg-yellow-500 text-gray-900 border-yellow-700 shadow-lg' 
                                                        : 'bg-gray-800 text-gray-300 border-gray-600 hover:bg-gray-700'
                                                    }
                                                `}
                                            >
                                                {isSelected ? <CheckCircle className="h-4 w-4 mr-2" /> : <PlusCircle className="h-4 w-4 mr-2 opacity-60" />}
                                                {item.name}
                                            </button>
                                        );
                                    })}
                                </div>
                            </div>
                        ))}
                    </div>

                    {/* Image Area and Action */}
                    <div className="flex flex-col items-center lg:order-2">
                        <h2 className="text-xl font-semibold text-yellow-400 mb-4 flex items-center">
                            <Image className="h-5 w-5 mr-2" />
                            {isEditing ? 'Edited Art' : 'Image Preview'}
                        </h2>
                        <div className="w-full max-w-sm sm:max-w-md aspect-[4/5] relative bg-black rounded-xl overflow-hidden shadow-2xl border-4 border-yellow-500">
                            {loading && (
                                <div className="absolute inset-0 bg-black bg-opacity-70 flex flex-col items-center justify-center z-10">
                                    <Loader2 className="h-10 w-10 text-yellow-400 animate-spin" />
                                    <p className="text-yellow-400 mt-3 font-medium">Forging New Trait...</p>
                                </div>
                            )}
                            <img 
                                src={displayImage}
                                alt="LeGods Style Editor Preview"
                                className="w-full h-full object-contain transition-opacity duration-300"
                                onError={(e) => { 
                                    e.target.onerror = null; 
                                    e.target.src = DEFAULT_IMAGE_URL;
                                }}
                            />
                        </div>
                        
                        <div className="mt-6 w-full max-w-sm sm:max-w-md space-y-4">
                            <p className="text-sm text-gray-400 font-semibold flex items-center justify-center mb-1">
                                <KeyRound className="h-4 w-4 mr-2" /> 2. Load NFT by Token ID
                            </p>
                            <div className="flex space-x-2">
                                <input
                                    type="number"
                                    placeholder="Enter Token ID (e.g., 101)"
                                    value={nftTokenId}
                                    onChange={(e) => { setNftTokenId(e.target.value); setError(null); setGeneratedImageUrl(null); }}
                                    className="flex-grow p-3 bg-gray-700 text-white rounded-full border border-gray-600 focus:ring-yellow-500 focus:border-yellow-500"
                                    disabled={loading}
                                />
                                <button
                                    onClick={handleNFTLoad}
                                    disabled={loading || !nftTokenId}
                                    className={`px-6 py-3 text-white rounded-full transition duration-200 shadow-md flex items-center 
                                        ${isImageLoaded ? 'bg-green-600 hover:bg-green-700' : 'bg-red-600 hover:bg-red-700'}
                                    `}
                                >
                                    <Zap className="h-5 w-5 mr-2" />
                                    Load
                                </button>
                            </div>

                            <button
                                onClick={generateNewOutfit}
                                disabled={!generateButtonEnabled}
                                className={`w-full flex items-center justify-center px-6 py-4 text-white font-bold text-lg rounded-full transition duration-300 shadow-xl transform active:scale-98 
                                    ${generateButtonEnabled ? 'bg-indigo-600 hover:bg-indigo-700' : 'bg-gray-600 cursor-not-allowed'}
                                `}
                            >
                                <Shirt className="h-6 w-6 mr-3" />
                                3. Generate {isEditing ? 'New Edit' : 'New Trait'}
                            </button>
                        </div>
                        
                        {error && (
                            <div className="mt-4 bg-red-800 border border-red-400 text-red-100 px-4 py-3 rounded-xl relative text-sm w-full max-w-sm sm:max-w-md" role="alert">
                                <strong className="font-bold">Error:</strong>
                                <span className="block sm:inline ml-1">{error}</span>
                            </div>
                        )}
                        {!isImageLoaded && (
                            <p className="text-center text-sm text-yellow-300 mt-3 p-2 border border-dashed border-yellow-600 rounded-lg w-full max-w-sm sm:max-w-md">
                                **ACTION REQUIRED:** Please load a **Token ID** to begin editing.
                            </p>
                        )}
                    </div>
                </div>
            </div>
        </div>
        </React.Fragment>
    );
};

export default App;

