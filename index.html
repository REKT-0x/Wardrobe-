<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI Background Changer</title>
    <!-- Load Tailwind CSS for modern styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        'primary': '#4f46e5',
                        'secondary': '#60a5fa',
                        'accent': '#facc15',
                    },
                    fontFamily: {
                        sans: ['Inter', 'sans-serif'],
                    },
                }
            }
        }
    </script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap');
        
        /* Custom spinner animation */
        .spinner {
            border-top-color: #4f46e5;
            -webkit-animation: spinner 1.5s linear infinite;
            animation: spinner 1.5s linear infinite;
        }
        @-webkit-keyframes spinner {
            0% { -webkit-transform: rotate(0deg); }
            100% { -webkit-transform: rotate(360deg); }
        }
        @keyframes spinner {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body class="bg-gray-50 min-h-screen flex flex-col items-center p-4 font-sans">

    <!-- Header -->
    <header class="w-full max-w-2xl text-center py-6">
        <h1 class="text-3xl font-bold text-gray-800">AI Background Studio</h1>
        <p class="text-gray-600 mt-1">Upload an image and describe the new scene!</p>
    </header>

    <!-- Main Application Container -->
    <main class="w-full max-w-2xl bg-white p-6 md:p-8 rounded-xl shadow-2xl space-y-6">

        <!-- Upload Section -->
        <div class="space-y-4">
            <h2 class="text-xl font-semibold text-gray-700">1. Upload Image</h2>
            <div id="image-upload-area" class="border-2 border-dashed border-gray-300 rounded-lg p-6 text-center hover:border-primary transition duration-300 cursor-pointer" onclick="document.getElementById('file-input').click()">
                <svg class="mx-auto h-12 w-12 text-gray-400" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16l4.586-4.586a2 2 0 012.828 0L16 16m-2-2l1.586-1.586a2 2 0 012.828 0L20 16m-2 2H6a2 2 0 01-2-2v-4.586a2 2 0 01.586-1.414l.828-.828a2 2 0 011.414-.586h.586a2 2 0 011.414.586l.828.828a2 2 0 01.586 1.414V16a2 2 0 01-2 2z" />
                </svg>
                <p class="mt-2 text-sm text-gray-600"><span class="font-medium text-primary">Click to upload</span> or drag and drop</p>
                <p class="text-xs text-gray-500">PNG, JPG, up to 4MB</p>
                <input type="file" id="file-input" accept="image/*" class="hidden" onchange="previewImage(event)">
            </div>
            
            <div id="image-preview" class="hidden relative">
                <img id="uploaded-img" class="w-full h-auto object-cover rounded-lg shadow-md" alt="Uploaded Image Preview">
                <button onclick="removeImage()" class="absolute top-2 right-2 p-1 bg-red-500 text-white rounded-full hover:bg-red-600 transition">
                    <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path></svg>
                </button>
            </div>
        </div>

        <!-- Prompt Section -->
        <div class="space-y-4">
            <h2 class="text-xl font-semibold text-gray-700">2. Describe New Background</h2>
            <textarea id="prompt-input" rows="3" placeholder="e.g., A cyberpunk cityscape at night, a serene Japanese garden in autumn, a spaceship cockpit." class="w-full p-3 border border-gray-300 rounded-lg focus:ring-primary focus:border-primary transition resize-none"></textarea>
        </div>
        
        <!-- Generate Button -->
        <button id="generate-button" onclick="generateBackground()" class="w-full flex justify-center items-center py-3 px-4 border border-transparent rounded-lg shadow-lg text-lg font-medium text-white bg-primary hover:bg-indigo-600 focus:outline-none focus:ring-4 focus:ring-indigo-500 focus:ring-opacity-50 transition duration-300 disabled:opacity-50 disabled:cursor-not-allowed">
            <span id="button-text">Generate New Background</span>
            <div id="loading-spinner" class="spinner h-5 w-5 border-4 border-t-white border-r-white border-b-primary border-l-white rounded-full ml-3 hidden"></div>
        </button>

        <!-- Output Section -->
        <div id="output-section" class="pt-6 border-t mt-6 border-gray-200 hidden">
            <h2 class="text-xl font-semibold text-gray-700 mb-4">3. Result</h2>
            <div id="message-box" class="hidden p-4 rounded-lg text-sm text-center" role="alert"></div>
            <div id="image-result" class="bg-gray-100 p-4 rounded-lg shadow-inner flex justify-center items-center">
                <img id="generated-img" class="w-full h-auto max-h-[500px] object-contain rounded-lg shadow-xl" alt="Generated Image" onerror="this.onerror=null; this.src='https://placehold.co/400x400/808080/FFFFFF?text=Error+Loading+Image'">
            </div>
        </div>

    </main>

    <script type="module">
        // Global variables provided by the environment
        const apiKey = "";
        const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-image-preview:generateContent?key=${apiKey}`;

        // DOM Elements
        const fileInput = document.getElementById('file-input');
        const imagePreview = document.getElementById('image-preview');
        const uploadedImg = document.getElementById('uploaded-img');
        const promptInput = document.getElementById('prompt-input');
        const generateButton = document.getElementById('generate-button');
        const buttonText = document.getElementById('button-text');
        const loadingSpinner = document.getElementById('loading-spinner');
        const outputSection = document.getElementById('output-section');
        const generatedImg = document.getElementById('generated-img');
        const messageBox = document.getElementById('message-box');

        let uploadedBase64Image = null;

        // --- Utility Functions ---

        /**
         * Converts a File object to a Base64 string.
         * @param {File} file - The image file to convert.
         * @returns {Promise<string>} - The base64 data string (without the mime type prefix).
         */
        function fileToBase64(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.readAsDataURL(file);
                reader.onload = () => {
                    // Extract the base64 part (remove "data:image/jpeg;base64,")
                    const base64String = reader.result.split(',')[1];
                    resolve(base64String);
                };
                reader.onerror = error => reject(error);
            });
        }

        /**
         * Shows a transient message box.
         * @param {string} message - The message text.
         * @param {string} type - 'success' or 'error'.
         */
        function showMessage(message, type) {
            messageBox.textContent = message;
            messageBox.className = 'p-4 rounded-lg text-sm text-center';
            if (type === 'error') {
                messageBox.classList.add('bg-red-100', 'text-red-700', 'border', 'border-red-300');
            } else {
                messageBox.classList.add('bg-green-100', 'text-green-700', 'border', 'border-green-300');
            }
            messageBox.classList.remove('hidden');
            setTimeout(() => {
                messageBox.classList.add('hidden');
            }, 5000);
        }

        /**
         * Handles exponential backoff for API calls.
         * @param {Function} fn - The function to retry.
         * @param {number} maxRetries - Maximum number of retries.
         * @param {number} delay - Initial delay in milliseconds.
         * @returns {Promise<any>}
         */
        async function fetchWithRetry(fn, maxRetries = 5, delay = 1000) {
            for (let i = 0; i < maxRetries; i++) {
                try {
                    const response = await fn();
                    if (response.status === 429 && i < maxRetries - 1) {
                        // Rate limit error (429) - wait and retry
                        await new Promise(resolve => setTimeout(resolve, delay * (2 ** i)));
                        continue;
                    }
                    if (!response.ok) {
                        const errorBody = await response.text();
                        throw new Error(`API Request failed with status ${response.status}: ${errorBody}`);
                    }
                    return response;
                } catch (error) {
                    console.error(`Attempt ${i + 1} failed:`, error);
                    if (i === maxRetries - 1) throw error;
                    await new Promise(resolve => setTimeout(resolve, delay * (2 ** i)));
                }
            }
        }

        // --- Core Application Logic ---

        /**
         * Previews the selected image and stores the Base64 data.
         * @param {Event} event - The change event from the file input.
         */
        window.previewImage = async function(event) {
            const file = event.target.files[0];
            if (!file) return;

            if (file.size > 4 * 1024 * 1024) { // Check file size (4MB limit)
                showMessage("Image is too large. Max size is 4MB.", 'error');
                fileInput.value = '';
                return;
            }

            try {
                // Show preview
                uploadedImg.src = URL.createObjectURL(file);
                imagePreview.classList.remove('hidden');
                document.getElementById('image-upload-area').classList.add('hidden');
                
                // Convert to Base64 for the API call
                uploadedBase64Image = await fileToBase64(file);
            } catch (e) {
                showMessage(`Could not read file: ${e.message}`, 'error');
                removeImage();
            }
            updateButtonState();
        }
        
        /**
         * Clears the image preview and resets the input.
         */
        window.removeImage = function() {
            uploadedImg.src = '';
            uploadedBase64Image = null;
            fileInput.value = '';
            imagePreview.classList.add('hidden');
            document.getElementById('image-upload-area').classList.remove('hidden');
            generatedImg.src = '';
            outputSection.classList.add('hidden');
            updateButtonState();
        }

        /**
         * Enables/disables the generate button based on input state.
         */
        function updateButtonState() {
            const isReady = uploadedBase64Image && promptInput.value.trim().length > 0;
            generateButton.disabled = !isReady;
        }

        promptInput.addEventListener('input', updateButtonState);
        document.addEventListener('DOMContentLoaded', updateButtonState);


        /**
         * Calls the Gemini API to replace the background of the uploaded image.
         */
        window.generateBackground = async function() {
            if (!uploadedBase64Image || generateButton.disabled) return;

            const prompt = `Replace the background of the main subject in this image with: ${promptInput.value.trim()}. Maintain the original aspect ratio and the look of the foreground object.`;
            
            // UI State: Loading
            generateButton.disabled = true;
            buttonText.textContent = "Generating...";
            loadingSpinner.classList.remove('hidden');
            outputSection.classList.add('hidden');
            generatedImg.src = '';


            const payload = {
                contents: [{
                    parts: [{ 
                        text: prompt 
                    }, {
                        inlineData: {
                            mimeType: "image/jpeg", // Assuming common mime type, adjust if needed
                            data: uploadedBase64Image
                        }
                    }]
                }],
                generationConfig: {
                    responseModalities: ['IMAGE'] // Requesting only the image response
                },
            };
            
            try {
                const response = await fetchWithRetry(() => fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                }));
                
                const result = await response.json();
                const base64Data = result?.candidates?.[0]?.content?.parts?.find(p => p.inlineData)?.inlineData?.data;

                if (!base64Data) {
                    const errorMessage = result.error?.message || "Generation failed: The model did not return an image. Try a different prompt or image.";
                    showMessage(errorMessage, 'error');
                    console.error("API Response Error:", result);
                    return;
                }

                const imageUrl = `data:image/png;base64,${base64Data}`;
                generatedImg.src = imageUrl;
                outputSection.classList.remove('hidden');
                showMessage("Success! New background generated.", 'success');

            } catch (error) {
                console.error("Fetch or API Error:", error);
                showMessage(`An error occurred: ${error.message}`, 'error');
            } finally {
                // UI State: Done
                loadingSpinner.classList.add('hidden');
                buttonText.textContent = "Generate New Background";
                updateButtonState(); // Re-enable if inputs are valid
            }
        }
    </script>
</body>
</html>

